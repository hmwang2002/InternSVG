"""
For understanding tasks, the answer generated by the model may not be in the expected format, so we need to clean the result.
"""
import os
import json
import argparse

from dataclasses import dataclass
from pathlib import Path
from typing import Set

from utils.api import build_client, chat
from utils.parallel_mapper import parallel_map


ALLOWED: Set[str] = {"A.", "B.", "C.", "D.", "X."}
PROMPT_TEMPLATE = (
    "You are a strict grading assistant. The ONLY valid outputs you can return "
    "are: 'A.', 'B.', 'C.', 'D.' or 'X.'. Given the RAW answer below, output "
    "the cleaned answer token EXACTLY with nothing else. If none or multiple "
    "choices can be extracted confidently, return 'X.'.\n\nRAW answer:\n{raw}\n\nCleaned answer:"
)

@dataclass
class TestData:
    id: int
    raw_str: str
    base_url: str
    api_key: str
    timeout: int
    output_path: Path
    retry: int
    max_tokens: int
    temperature: float

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input_path", type=str, required=True)
    parser.add_argument("--output_path", type=str, required=True)
    parser.add_argument("--base_url", type=str, required=True)
    parser.add_argument("--api_key", type=str, required=True)
    parser.add_argument("--timeout", type=int, required=True)
    parser.add_argument("--retry", type=int, required=True)
    parser.add_argument("--max_tokens", type=int, required=True)
    parser.add_argument("--temperature", type=float, required=True)
    parser.add_argument("--max_workers", type=int, required=True)

    return parser.parse_args()

def clean_answer(data: TestData):
    client = build_client(base_url=data.base_url, api_key=data.api_key, timeout=data.timeout)
    prompt = PROMPT_TEMPLATE.format(raw=data.raw_str)
    response = chat(client=client, model="gpt-4o-mini", text=prompt, temperature=data.temperature, max_tokens=data.max_tokens, retry=data.retry)
    if response is None:
        return
    with open(data.output_path, "a") as fp:
        fp.write(json.dumps({"id": data.id, "result": response}) + "\n")

def main():
    args = parse_args()
    input_path = args.input_path
    output_path = args.output_path
    base_url = args.base_url
    api_key = args.api_key
    timeout = args.timeout
    retry = args.retry
    max_tokens = args.max_tokens
    temperature = args.temperature
    max_workers = args.max_workers

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    data_list = []
    with open(input_path, "r") as fp:
        for line in fp:
            line = line.strip()
            if not line:
                continue
            obj = json.loads(line)
            id = obj["id"]
            raw_str = obj["result"]
            data = TestData(id=id, raw_str=raw_str, base_url=base_url, api_key=api_key, timeout=timeout, output_path=output_path, retry=retry, max_tokens=max_tokens, temperature=temperature)
            data_list.append(data)
    
    parallel_map(clean_answer, data_list, max_workers=max_workers)

    existing_results = {}
    with open(output_path, "r") as fp:
        for line in fp:
            line = line.strip()
            if not line:
                continue
            obj = json.loads(line)
            existing_results[obj["id"]] = obj["result"]
    sorted_items = sorted(existing_results.items(), key=lambda kv: kv[0])
    with open(output_path, "w") as fp:
        for _id, _res in sorted_items:
            fp.write(json.dumps({"id": _id, "result": _res}) + "\n")
    print(f"[OK] {len(sorted_items)} items cleaned and sorted")

if __name__ == "__main__":
    main()